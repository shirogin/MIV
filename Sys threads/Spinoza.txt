-int access(const char *pathname, int mode);
	#include <unistd.h>
	#Vérifie les droits d'accès au fichier pathname
	#Mode= (On peut combiner les modes avec l'opérateur OU binaire '|')
		F_OK : Vérifie si le fichier existe
		R_OK : Vérifie la lecture du fichier
		W_OK : Vérifie l'écriture du fichier
		X_OK : Vérifie l'exécution du fichier
	#Renvoie 0 s'il réussit, -1 sinon

-int open(const char *pathname, int flags, mode_t mode);
	#include <sys/types.h>
	 include <sys/stat.h>
	 include <fcntl.h>
	#Ouvre ou Crée un fichier
	#flags= (On peut combiner les modes avec l'opérateur OU binaire '|')
		O_EXCL : Combiner avec le flag 'O_CREAT', Renvoie -1 si le fichier existe et essaie d'être créer
		O_RDONLY : Ouvre le fichier en mode 'lecture seulement'
		O_RDWR : Ouvre le fichier en mode 'Lecture & Ecriture'
		O_WRONLY : Ouvre le fichier en mode 'Ecriture seulement'
		O_APPEND : Ouvre le fichier en mode 'ajout'
		O_CREAT : (Crée un fichier s'il n'existe pas avec les droits décrits par mode)
			#mode=S_IAB
				Si A = R | W | X  alors  B = USR | GRP | OTH
				Si A = RWX  alors  B = U | G | O
		O_TRUNC : Si fichier en mode ecriture, tronque sa longueur à nulle

	#Renvoie le descripteur de fichier (entier) ou -1 si erreur quelconque

-ssize_t read(int fd, void *buf, size_t count);
	#include <unistd.h>
	#Lis count octet(s) depuis le descripteur de fichier fd au buffer *buf
	#Renvoie 0 à la fin du fichier, -1 si il ya erreur

-ssize_t write(int fd, const void *buf, size_t count);
	#include <unistd.h>
	#Ecris count octet(s) depuis le buffer *buf au descripteur de fichier fd

-int stat(const char *path, struct stat *buf);
	#include <sys/types.h>
	 include <sys/stat.h>
	#Rempli la structure *buf des informations du fichier path
	#Champ de Struct stat :
		mode_t    st_mode     /* Droits d'accèes | affichable avec %o */
			S_ISREG(st_mode)    Renvoie 0 si ce n'est pas un fichier ordinaire
			S_ISDIR(st_mode)	Renvoie 0 si ce n'est pas un répertoire
			printf("%c",buf.st_mode & <mode> ? '<caractère>' : '-');
		off_t     st_size     /* Taille totale en octets */
		time_t    st_mtime    /* Date dernière modification */
		uid_t     st_uid      /* UID propiétaire */
            printf("%s",getpwuid(buf.st_uid)->pw_name);
        ino_t     st_ino      /* Numéro inoeud

-void signal_callback_handler(int signum){<Déroutement>}
 #signal(SIGXXX, signal_callback_handler);

-pid_t fork(void);
    #Crée un processus fils
    #Renvoie 0 dans le processus fils, renvoie PID du fils dans le processus père

-int kill(pid_t pid, int sig);
    #include <signal.h>
    #Envoie le signal sig au processus 
    #Renvoie 0 si réussi, -1 sinon

-pid_t waitpid(pid_t pid, int *status, int options);
    #include <sys/wait.h>
    #Attend la terminaison du processus pid, et sauvegarde son retour dans status
    #options = 
        WNOHANG : ne suspend pas l'exécution

-pthread_t pthread_self(void);
    #include <pthread.h>
    #Renvoie l'id du thread appellant

-void pthread_exit(void *retval);
    #include <pthread_self>
    #Termine le thread appellant et renvoie val

-int pthread_create(pthread_t *thr, NULL, void Routine, NULL);
    #include <pthread.h>
    #Lance un thread dans le processus appellant
    #Renvoie 0 si réussi, autre sinon

-int pthread_join(pthread_t thread, void **retval);
    #include <pthread.h>
    #Suspend en attendant la terminaison de thread, et copie le retour du thread dans retval
    #Renvoie 0 si réussi, autre sinon

-int pthread_cancel(pthread_t thread);
    #include <pthread.h>
    #Détruit thread
    #Renvoie 0 si réussi, autre sinon

-gcc prog.c -o prog -lqthread

-mount : Affiche la liste des périphériques en montages
-mount -tvfat <Périphérique> <Répertoire>
-umount /dev/sdX : Démonte le périphérique
-umount <Répertoire>
-fdisk -l : Affiche les partitions du disque
-mkfs -textX <Périphérique> : Formate un périphérique

